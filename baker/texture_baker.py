import bpy
from bpy.types import Panel, Operator, PropertyGroup
from bpy.props import (
    EnumProperty,
    BoolProperty,
    IntProperty,
    PointerProperty,
    StringProperty,
    FloatProperty,
)
from mathutils import Vector

TEMP_PREFIX = "TB_TEMP_"


# ---------------------------------------------------------------------------
# Utilities
# ---------------------------------------------------------------------------

def debug_print(settings, *args):
    if settings.debug_mode:
        print("[TextureBaker]", *args)


def get_principled_bsdf(mat):
    if not mat or not mat.use_nodes or not mat.node_tree:
        return None
    for node in mat.node_tree.nodes:
        if node.type == 'BSDF_PRINCIPLED':
            return node
    return None


def find_ao_node(mat):
    if not mat or not mat.use_nodes or not mat.node_tree:
        return None
    for node in mat.node_tree.nodes:
        if node.type == 'AMBIENT_OCCLUSION':
            return node
    return None


def find_id_core_rgb_alpha(mat):
    """
    Look for the per-material ID Core node generated by your ID System add-on:

      Node tree name:  ID_Core__<material.name>
      Outputs:         RGB_ID (color), Alpha_ID (float)

    Returns (core_node, rgb_socket, alpha_socket) or (None, None, None)
    """
    if not mat or not mat.use_nodes or not mat.node_tree:
        return None, None, None

    nt = mat.node_tree
    group_name = f"ID_Core__{mat.name}"

    for node in nt.nodes:
        if node.type == 'GROUP' and node.node_tree and node.node_tree.name == group_name:
            rgb = node.outputs.get("RGB_ID")
            alpha = node.outputs.get("Alpha_ID")
            return node, rgb, alpha

    return None, None, None


def get_material_output(mat):
    if not mat or not mat.use_nodes or not mat.node_tree:
        return None
    out_nodes = [n for n in mat.node_tree.nodes if n.type == 'OUTPUT_MATERIAL']
    if not out_nodes:
        return None
    for n in out_nodes:
        if getattr(n, "is_active_output", False):
            return n
    return out_nodes[0]


def get_map_suffix(map_type: str) -> str:
    return {
        'RMA':   "_RMA",
        'MRA':   "_MRA",
        'OBD':   "_OBD",
        'TSE':   "_TSE",
        'N':     "_N",
        'PC':    "_PC",
        'ID':    "_ID",     # legacy / single-ID if ever used
        'ID_C':  "_C_ID",   # Color ID (RGB_ID)
        'ID_A':  "_A_ID",   # Alpha ID (Alpha_ID)
        'C':     "_C",
    }.get(map_type, "_MAP")


def ensure_image_for_map(settings, map_type, context):
    active = context.view_layer.objects.active
    base_name = active.name if active else "Baked"
    img_name = base_name + get_map_suffix(map_type)
    img = bpy.data.images.get(img_name)
    if img is None:
        img = bpy.data.images.new(
            img_name,
            width=settings.resolution_x,
            height=settings.resolution_y,
            alpha=True,
            float_buffer=False,
        )
    return img


def clear_temp_nodes_from_material(mat, settings):
    if not mat or not mat.use_nodes or not mat.node_tree:
        return

    nt = mat.node_tree

    # Restore Material Output to a non-temp Principled if possible
    out = get_material_output(mat)
    if out:
        original_pb = None
        for node in nt.nodes:
            if node.type == 'BSDF_PRINCIPLED' and not node.name.startswith(TEMP_PREFIX):
                original_pb = node
                break
        if original_pb:
            nt.links.new(original_pb.outputs.get('BSDF'), out.inputs['Surface'])
            debug_print(settings, f"Restored Material Output to {original_pb.name} in {mat.name}")

    # Remove temp nodes
    to_remove = [n for n in nt.nodes if n.name.startswith(TEMP_PREFIX)]
    for n in to_remove:
        debug_print(settings, f"Removing temp node {n.name} in {mat.name}")
        nt.nodes.remove(n)


def create_temp_principled_and_image(mat, settings, shared_image, map_type):
    """Helper to create a temp Principled + Image node and hook it to Output."""
    nt = mat.node_tree
    pb = get_principled_bsdf(mat)
    out = get_material_output(mat)
    if pb is None or out is None:
        return None, None, None

    temp_pb = nt.nodes.new("ShaderNodeBsdfPrincipled")
    temp_pb.name = f"{TEMP_PREFIX}Principled_{map_type}"
    temp_pb.label = f"TB TEMP Principled ({map_type})"
    temp_pb.location = pb.location + Vector((350.0, 0.0))

    img_node = nt.nodes.new("ShaderNodeTexImage")
    img_node.name = f"{TEMP_PREFIX}Image_{map_type}"
    img_node.label = f"TB TEMP Image ({map_type})"
    img_node.image = shared_image
    img_node.location = temp_pb.location + Vector((250.0, 0.0))

    # Make sure this image node is the active one for this material
    nt.nodes.active = img_node

    nt.links.new(temp_pb.outputs['BSDF'], out.inputs['Surface'])

    # Ensure emission strength is 1.0 if present
    emission_strength_input = temp_pb.inputs.get("Emission Strength")
    if emission_strength_input is not None:
        emission_strength_input.default_value = 1.0

    return temp_pb, img_node, out


def connect_emission_color(temp_pb, color_socket, settings, mat):
    # Version-safe emission input
    emission_input = temp_pb.inputs.get("Emission") or temp_pb.inputs.get("Emission Color")
    if emission_input is not None:
        temp_pb.id_data.links.new(color_socket, emission_input)
        debug_print(settings, f"Connected color to Emission of {temp_pb.name} in {mat.name}")
    else:
        debug_print(settings, f"WARNING: No Emission input found on {temp_pb.name} in {mat.name}")


# ---------------------------------------------------------------------------
# Per-map material preparation
# ---------------------------------------------------------------------------

def prepare_material_for_rma(mat, settings, shared_image, report_data):
    if not mat or not mat.use_nodes or not mat.node_tree:
        return
    nt = mat.node_tree
    pb = get_principled_bsdf(mat)
    if pb is None:
        msg = f"Skipped material '{mat.name}' (no Principled BSDF)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    clear_temp_nodes_from_material(mat, settings)

    pb = get_principled_bsdf(mat)
    out = get_material_output(mat)
    if pb is None or out is None:
        msg = f"Skipped material '{mat.name}' after cleanup (no PB or output)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    temp_pb, img_node, _ = create_temp_principled_and_image(mat, settings, shared_image, "RMA")
    if temp_pb is None:
        return

    combine = nt.nodes.new("ShaderNodeCombineColor")
    combine.name = f"{TEMP_PREFIX}Combine_RMA"
    combine.label = "TB TEMP Combine (RMA)"
    combine.mode = 'RGB'
    combine.location = pb.location + Vector((150.0, -150.0))

    # AO logic
    ao_node = find_ao_node(mat)
    if ao_node:
        debug_print(settings, f"Using existing AO node {ao_node.name} in {mat.name}")
    elif settings.generate_ao:
        ao_node = nt.nodes.new("ShaderNodeAmbientOcclusion")
        ao_node.name = f"{TEMP_PREFIX}AO_RMA"
        ao_node.label = "TB TEMP AO (RMA)"
        ao_node.location = pb.location + Vector((-150.0, -250.0))
        ao_node.inputs["Color"].default_value = (1.0, 1.0, 1.0, 1.0)
        ao_node.samples = settings.ao_samples
        ao_node.inside = settings.ao_inside
        ao_node.only_local = settings.ao_only_local
        dist_input = ao_node.inputs.get("Distance")
        if dist_input is not None:
            dist_input.default_value = settings.ao_distance

        normal_input = pb.inputs.get("Normal")
        if normal_input and normal_input.is_linked:
            from_socket = normal_input.links[0].from_socket
            nt.links.new(from_socket, ao_node.inputs["Normal"])
            debug_print(settings, f"Connected normal chain to AO in {mat.name}")
    else:
        debug_print(settings, f"No AO used in {mat.name}; Blue will be 1.0")

    # Roughness -> R
    rough_input = pb.inputs.get("Roughness")
    if rough_input:
        if rough_input.is_linked:
            from_socket = rough_input.links[0].from_socket
            nt.links.new(from_socket, combine.inputs["Red"])
        else:
            combine.inputs["Red"].default_value = rough_input.default_value

    # Metallic -> G
    metal_input = pb.inputs.get("Metallic")
    if metal_input:
        if metal_input.is_linked:
            from_socket = metal_input.links[0].from_socket
            nt.links.new(from_socket, combine.inputs["Green"])
        else:
            combine.inputs["Green"].default_value = metal_input.default_value

    # AO -> B or 1.0
    if ao_node:
        out_socket = ao_node.outputs.get("AO") or ao_node.outputs.get("Color")
        if out_socket:
            nt.links.new(out_socket, combine.inputs["Blue"])
        else:
            combine.inputs["Blue"].default_value = 1.0
    else:
        combine.inputs["Blue"].default_value = 1.0

    connect_emission_color(temp_pb, combine.outputs["Color"], settings, mat)


def prepare_material_for_mra(mat, settings, shared_image, report_data):
    # Metallic â†’ R, Roughness â†’ G, AO â†’ B (same AO logic as RMA)
    if not mat or not mat.use_nodes or not mat.node_tree:
        return
    nt = mat.node_tree
    pb = get_principled_bsdf(mat)
    if pb is None:
        msg = f"Skipped material '{mat.name}' (no Principled BSDF)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    clear_temp_nodes_from_material(mat, settings)

    pb = get_principled_bsdf(mat)
    out = get_material_output(mat)
    if pb is None or out is None:
        msg = f"Skipped material '{mat.name}' after cleanup (no PB or output)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    temp_pb, img_node, _ = create_temp_principled_and_image(mat, settings, shared_image, "MRA")
    if temp_pb is None:
        return

    combine = nt.nodes.new("ShaderNodeCombineColor")
    combine.name = f"{TEMP_PREFIX}Combine_MRA"
    combine.label = "TB TEMP Combine (MRA)"
    combine.mode = 'RGB'
    combine.location = pb.location + Vector((150.0, -150.0))

    # AO logic same as RMA
    ao_node = find_ao_node(mat)
    if ao_node:
        debug_print(settings, f"Using existing AO node {ao_node.name} in {mat.name}")
    elif settings.generate_ao:
        ao_node = nt.nodes.new("ShaderNodeAmbientOcclusion")
        ao_node.name = f"{TEMP_PREFIX}AO_MRA"
        ao_node.label = "TB TEMP AO (MRA)"
        ao_node.location = pb.location + Vector((-150.0, -250.0))
        ao_node.inputs["Color"].default_value = (1.0, 1.0, 1.0, 1.0)
        ao_node.samples = settings.ao_samples
        ao_node.inside = settings.ao_inside
        ao_node.only_local = settings.ao_only_local
        dist_input = ao_node.inputs.get("Distance")
        if dist_input is not None:
            dist_input.default_value = settings.ao_distance

        normal_input = pb.inputs.get("Normal")
        if normal_input and normal_input.is_linked:
            from_socket = normal_input.links[0].from_socket
            nt.links.new(from_socket, ao_node.inputs["Normal"])
    else:
        debug_print(settings, f"No AO used in {mat.name}; Blue will be 1.0")

    # Metallic -> R
    metal_input = pb.inputs.get("Metallic")
    if metal_input:
        if metal_input.is_linked:
            from_socket = metal_input.links[0].from_socket
            nt.links.new(from_socket, combine.inputs["Red"])
        else:
            combine.inputs["Red"].default_value = metal_input.default_value

    # Roughness -> G
    rough_input = pb.inputs.get("Roughness")
    if rough_input:
        if rough_input.is_linked:
            from_socket = rough_input.links[0].from_socket
            nt.links.new(from_socket, combine.inputs["Green"])
        else:
            combine.inputs["Green"].default_value = rough_input.default_value

    # AO -> B or 1.0
    if ao_node:
        out_socket = ao_node.outputs.get("AO") or ao_node.outputs.get("Color")
        if out_socket:
            nt.links.new(out_socket, combine.inputs["Blue"])
        else:
            combine.inputs["Blue"].default_value = 1.0
    else:
        combine.inputs["Blue"].default_value = 1.0

    connect_emission_color(temp_pb, combine.outputs["Color"], settings, mat)


def prepare_material_for_obd(mat, settings, shared_image, report_data):
    # R = Alpha, G = 0.0, B = 0.0
    if not mat or not mat.use_nodes or not mat.node_tree:
        return
    nt = mat.node_tree
    pb = get_principled_bsdf(mat)
    if pb is None:
        msg = f"Skipped material '{mat.name}' (no Principled BSDF)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    clear_temp_nodes_from_material(mat, settings)
    pb = get_principled_bsdf(mat)
    out = get_material_output(mat)
    if pb is None or out is None:
        msg = f"Skipped material '{mat.name}' after cleanup (no PB or output)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    temp_pb, img_node, _ = create_temp_principled_and_image(mat, settings, shared_image, "OBD")
    if temp_pb is None:
        return

    combine = nt.nodes.new("ShaderNodeCombineColor")
    combine.name = f"{TEMP_PREFIX}Combine_OBD"
    combine.label = "TB TEMP Combine (OBD)"
    combine.mode = 'RGB'
    combine.location = pb.location + Vector((150.0, -150.0))

    alpha_input = pb.inputs.get("Alpha")
    if alpha_input:
        if alpha_input.is_linked:
            from_socket = alpha_input.links[0].from_socket
            nt.links.new(from_socket, combine.inputs["Red"])
        else:
            combine.inputs["Red"].default_value = alpha_input.default_value
    combine.inputs["Green"].default_value = 0.0
    combine.inputs["Blue"].default_value = 0.0

    connect_emission_color(temp_pb, combine.outputs["Color"], settings, mat)


def prepare_material_for_tse(mat, settings, shared_image, report_data):
    # R = 0.0, G = Specular/IOR Level, B = Emission input (0.0 if unlinked)
    if not mat or not mat.use_nodes or not mat.node_tree:
        return
    nt = mat.node_tree
    pb = get_principled_bsdf(mat)
    if pb is None:
        msg = f"Skipped material '{mat.name}' (no Principled BSDF)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    clear_temp_nodes_from_material(mat, settings)
    pb = get_principled_bsdf(mat)
    out = get_material_output(mat)
    if pb is None or out is None:
        msg = f"Skipped material '{mat.name}' after cleanup (no PB or output)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    temp_pb, img_node, _ = create_temp_principled_and_image(mat, settings, shared_image, "TSE")
    if temp_pb is None:
        return

    combine = nt.nodes.new("ShaderNodeCombineColor")
    combine.name = f"{TEMP_PREFIX}Combine_TSE"
    combine.label = "TB TEMP Combine (TSE)"
    combine.mode = 'RGB'
    combine.location = pb.location + Vector((150.0, -150.0))

    # R = 0.0
    combine.inputs["Red"].default_value = 0.0

    # G = Specular IOR Level (4.x) or Specular (3.x)
    spec_input = pb.inputs.get("Specular IOR Level") or pb.inputs.get("Specular")
    if spec_input:
        if spec_input.is_linked:
            from_socket = spec_input.links[0].from_socket
            nt.links.new(from_socket, combine.inputs["Green"])
        else:
            combine.inputs["Green"].default_value = spec_input.default_value
    else:
        combine.inputs["Green"].default_value = 0.0

    # B = Emission input if linked, else 0.0
    emis_input = pb.inputs.get("Emission") or pb.inputs.get("Emission Color")
    if emis_input and emis_input.is_linked:
        from_socket = emis_input.links[0].from_socket
        nt.links.new(from_socket, combine.inputs["Blue"])
    else:
        combine.inputs["Blue"].default_value = 0.0

    connect_emission_color(temp_pb, combine.outputs["Color"], settings, mat)


def prepare_material_for_pc(mat, settings, shared_image, report_data):
    """
    Color (PC): Base Color + alpha using a Transparent/Emission mix, baked with Combined.
    """
    if not mat or not mat.use_nodes or not mat.node_tree:
        return
    nt = mat.node_tree
    pb = get_principled_bsdf(mat)
    if pb is None:
        msg = f"Skipped material '{mat.name}' (no Principled BSDF)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    clear_temp_nodes_from_material(mat, settings)
    pb = get_principled_bsdf(mat)
    out = get_material_output(mat)
    if pb is None or out is None:
        msg = f"Skipped material '{mat.name}' after cleanup (no PB or output)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    # Source color from Base Color
    base_input = pb.inputs.get("Base Color")
    if base_input and base_input.is_linked:
        color_socket = base_input.links[0].from_socket
    else:
        # Create an RGB node with the default base color
        rgb_node = nt.nodes.new("ShaderNodeRGB")
        rgb_node.name = f"{TEMP_PREFIX}BaseColor_PC"
        rgb_node.label = "TB TEMP BaseColor (PC)"
        rgb_node.location = pb.location + Vector((-200.0, 0.0))
        if base_input:
            rgb_node.outputs["Color"].default_value = base_input.default_value
        color_socket = rgb_node.outputs["Color"]

    # Alpha from Principled Alpha (linked or value) â€“ default to 1.0
    alpha_input = pb.inputs.get("Alpha")
    if alpha_input and alpha_input.is_linked:
        alpha_socket = alpha_input.links[0].from_socket
    else:
        # Use value as scalar; if no input, default to 1.0
        alpha_value = alpha_input.default_value if alpha_input else 1.0
        val_node = nt.nodes.new("ShaderNodeValue")
        val_node.name = f"{TEMP_PREFIX}Alpha_PC"
        val_node.label = "TB TEMP Alpha (PC)"
        val_node.location = pb.location + Vector((-200.0, -200.0))
        val_node.outputs[0].default_value = alpha_value
        alpha_socket = val_node.outputs[0]

    # Build Transparent/Emission mix
    transp = nt.nodes.new("ShaderNodeBsdfTransparent")
    transp.name = f"{TEMP_PREFIX}Transparent_PC"
    transp.label = "TB TEMP Transparent (PC)"
    transp.location = pb.location + Vector((150.0, 0.0))

    emis = nt.nodes.new("ShaderNodeEmission")
    emis.name = f"{TEMP_PREFIX}Emission_PC"
    emis.label = "TB TEMP Emission (PC)"
    emis.location = pb.location + Vector((150.0, -150.0))
    nt.links.new(color_socket, emis.inputs["Color"])

    mix = nt.nodes.new("ShaderNodeMixShader")
    mix.name = f"{TEMP_PREFIX}Mix_PC"
    mix.label = "TB TEMP Mix (PC)"
    mix.location = pb.location + Vector((350.0, -50.0))
    nt.links.new(transp.outputs["BSDF"], mix.inputs[1])
    nt.links.new(emis.outputs["Emission"], mix.inputs[2])
    nt.links.new(alpha_socket, mix.inputs["Fac"])

    # Temp image node
    img_node = nt.nodes.new("ShaderNodeTexImage")
    img_node.name = f"{TEMP_PREFIX}Image_PC"
    img_node.label = "TB TEMP Image (PC)"
    img_node.image = shared_image
    img_node.location = mix.location + Vector((250.0, 0.0))
    nt.nodes.active = img_node

    out = get_material_output(mat)
    nt.links.new(mix.outputs["Shader"], out.inputs["Surface"])


def prepare_material_for_id(mat, settings, shared_image, report_data):
    """
    ID Color pass (C_ID):
      - Use RGB_ID from the ID Core group
      - Connect it to Emission COLOR (not strength)
      - Bake as EMIT
    """
    if not mat or not mat.use_nodes or not mat.node_tree:
        return
    nt = mat.node_tree
    pb = get_principled_bsdf(mat)
    if pb is None:
        msg = f"Skipped material '{mat.name}' (no Principled BSDF)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    clear_temp_nodes_from_material(mat, settings)
    pb = get_principled_bsdf(mat)
    out = get_material_output(mat)
    if pb is None or out is None:
        msg = f"Skipped material '{mat.name}' after cleanup (no PB or output)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    # TEMP principled + image node, tagged as ID_C so nodes don't clash with other maps
    temp_pb, img_node, _ = create_temp_principled_and_image(mat, settings, shared_image, "ID_C")
    if temp_pb is None:
        return

    # Try to use RGB_ID from ID Core. If not found, gracefully fall back to Base Color.
    core_node, rgb_socket, alpha_socket = find_id_core_rgb_alpha(mat)
    if core_node and rgb_socket:
        color_socket = rgb_socket
        debug_print(settings, f"Using RGB_ID from ID Core in '{mat.name}' for Color ID.")
    else:
        debug_print(settings, f"No ID Core RGB_ID for '{mat.name}', falling back to Base Color.")
        base_input = pb.inputs.get("Base Color")
        if base_input and base_input.is_linked:
            color_socket = base_input.links[0].from_socket
        elif base_input:
            rgb_node = nt.nodes.new("ShaderNodeRGB")
            rgb_node.name = f"{TEMP_PREFIX}BaseColor_ID_C"
            rgb_node.label = "TB TEMP BaseColor (ID_C)"
            rgb_node.location = pb.location + Vector((-200.0, 0.0))
            rgb_node.outputs["Color"].default_value = base_input.default_value
            color_socket = rgb_node.outputs["Color"]
        else:
            # Worst case: just use flat white
            rgb_node = nt.nodes.new("ShaderNodeRGB")
            rgb_node.name = f"{TEMP_PREFIX}BaseColor_ID_C"
            rgb_node.label = "TB TEMP BaseColor (ID_C)"
            rgb_node.location = pb.location + Vector((-200.0, 0.0))
            rgb_node.outputs["Color"].default_value = (1.0, 1.0, 1.0, 1.0)
            color_socket = rgb_node.outputs["Color"]

    connect_emission_color(temp_pb, color_socket, settings, mat)


def prepare_material_for_id_alpha(mat, settings, shared_image, report_data):
    """
    ID Alpha pass (A_ID):
      - Use Alpha_ID from the ID Core group
      - Convert it to a greyscale color
      - Connect that to Emission COLOR (not strength)
      - Bake as EMIT
    """
    if not mat or not mat.use_nodes or not mat.node_tree:
        return
    nt = mat.node_tree
    pb = get_principled_bsdf(mat)
    if pb is None:
        msg = f"Skipped material '{mat.name}' (no Principled BSDF)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    clear_temp_nodes_from_material(mat, settings)
    pb = get_principled_bsdf(mat)
    out = get_material_output(mat)
    if pb is None or out is None:
        msg = f"Skipped material '{mat.name}' after cleanup (no PB or output)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    # TEMP principled + image node, tagged as ID_A
    temp_pb, img_node, _ = create_temp_principled_and_image(mat, settings, shared_image, "ID_A")
    if temp_pb is None:
        return

    core_node, rgb_socket, alpha_socket = find_id_core_rgb_alpha(mat)
    color_socket = None

    if core_node and alpha_socket:
        # Turn the scalar Alpha_ID into greyscale color
        combine = nt.nodes.new("ShaderNodeCombineColor")
        combine.name = f"{TEMP_PREFIX}Combine_ID_A"
        combine.label = "TB TEMP Combine (ID_A)"
        combine.mode = 'RGB'
        combine.location = pb.location + Vector((150.0, -150.0))

        # Feed Alpha into R, G, B to get a greyscale output
        nt.links.new(alpha_socket, combine.inputs["Red"])
        nt.links.new(alpha_socket, combine.inputs["Green"])
        nt.links.new(alpha_socket, combine.inputs["Blue"])

        color_socket = combine.outputs["Color"]
        debug_print(settings, f"Using Alpha_ID from ID Core in '{mat.name}' for Alpha ID.")
    else:
        debug_print(settings, f"No ID Core Alpha_ID for '{mat.name}', falling back to Base Color alpha.")
        # Fallback: use Principled Alpha as greyscale
        alpha_input = pb.inputs.get("Alpha")
        if alpha_input and alpha_input.is_linked:
            alpha_socket = alpha_input.links[0].from_socket
        else:
            val_node = nt.nodes.new("ShaderNodeValue")
            val_node.name = f"{TEMP_PREFIX}Alpha_ID_A"
            val_node.label = "TB TEMP Alpha (ID_A)"
            val_node.location = pb.location + Vector((-200.0, -200.0))
            val_node.outputs[0].default_value = alpha_input.default_value if alpha_input else 1.0
            alpha_socket = val_node.outputs[0]

        combine = nt.nodes.new("ShaderNodeCombineColor")
        combine.name = f"{TEMP_PREFIX}Combine_ID_A"
        combine.label = "TB TEMP Combine (ID_A)"
        combine.mode = 'RGB'
        combine.location = pb.location + Vector((150.0, -150.0))
        nt.links.new(alpha_socket, combine.inputs["Red"])
        nt.links.new(alpha_socket, combine.inputs["Green"])
        nt.links.new(alpha_socket, combine.inputs["Blue"])

        color_socket = combine.outputs["Color"]

    connect_emission_color(temp_pb, color_socket, settings, mat)


def prepare_material_for_diffuse(mat, settings, shared_image, report_data):
    # Diffuse (C): Base Color; optional greyscale via HSV + Bright/Contrast; Emit bake
    if not mat or not mat.use_nodes or not mat.node_tree:
        return
    nt = mat.node_tree
    pb = get_principled_bsdf(mat)
    if pb is None:
        msg = f"Skipped material '{mat.name}' (no Principled BSDF)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    clear_temp_nodes_from_material(mat, settings)
    pb = get_principled_bsdf(mat)
    out = get_material_output(mat)
    if pb is None or out is None:
        msg = f"Skipped material '{mat.name}' after cleanup (no PB or output)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    temp_pb, img_node, _ = create_temp_principled_and_image(mat, settings, shared_image, "C")
    if temp_pb is None:
        return

    base_input = pb.inputs.get("Base Color")

    # Determine source color socket
    if base_input and base_input.is_linked:
        src_socket = base_input.links[0].from_socket
    else:
        rgb_node = nt.nodes.new("ShaderNodeRGB")
        rgb_node.name = f"{TEMP_PREFIX}BaseColor_C"
        rgb_node.label = "TB TEMP BaseColor (C)"
        rgb_node.location = pb.location + Vector((-200.0, 0.0))
        if base_input:
            rgb_node.outputs["Color"].default_value = base_input.default_value
        src_socket = rgb_node.outputs["Color"]

    color_socket = src_socket

    # Optional greyscale pipeline
    if settings.diffuse_grayscale:
        hsv = nt.nodes.new("ShaderNodeHueSaturation")
        hsv.name = f"{TEMP_PREFIX}HSV_C"
        hsv.label = "TB TEMP HSV (C)"
        hsv.location = pb.location + Vector((0.0, -150.0))
        hsv.inputs["Saturation"].default_value = 0.0
        nt.links.new(src_socket, hsv.inputs["Color"])

        bc = nt.nodes.new("ShaderNodeBrightContrast")
        bc.name = f"{TEMP_PREFIX}BC_C"
        bc.label = "TB TEMP Bright/Contrast (C)"
        bc.location = hsv.location + Vector((200.0, 0.0))
        bc.inputs["Bright"].default_value = 0.1
        nt.links.new(hsv.outputs["Color"], bc.inputs["Color"])

        color_socket = bc.outputs["Color"]

    connect_emission_color(temp_pb, color_socket, settings, mat)


def prepare_material_for_normal(mat, settings, shared_image, report_data):
    # Only ensure an Image Texture node for the normal bake
    if not mat or not mat.use_nodes or not mat.node_tree:
        return
    nt = mat.node_tree

    clear_temp_nodes_from_material(mat, settings)
    out = get_material_output(mat)
    if out is None:
        msg = f"Skipped material '{mat.name}' (no Material Output)."
        report_data["skipped"].append(msg)
        debug_print(settings, msg)
        return

    img_node = nt.nodes.new("ShaderNodeTexImage")
    img_node.name = f"{TEMP_PREFIX}Image_N"
    img_node.label = "TB TEMP Image (N)"
    img_node.image = shared_image
    img_node.location = out.location + Vector((250.0, 0.0))
    nt.nodes.active = img_node


# ---------------------------------------------------------------------------
# Dispatcher for selected objects
# ---------------------------------------------------------------------------

def prepare_selected_objects_for_map(context, settings):
    map_type = settings.map_type
    shared_image = ensure_image_for_map(settings, map_type, context)
    report_data = {"skipped": [], "processed": []}

    for obj in context.selected_objects:
        if obj.type != 'MESH':
            continue
        for slot in obj.material_slots:
            mat = slot.material
            if not mat:
                continue

            if map_type == 'RMA':
                prepare_material_for_rma(mat, settings, shared_image, report_data)
            elif map_type == 'MRA':
                prepare_material_for_mra(mat, settings, shared_image, report_data)
            elif map_type == 'OBD':
                prepare_material_for_obd(mat, settings, shared_image, report_data)
            elif map_type == 'TSE':
                prepare_material_for_tse(mat, settings, shared_image, report_data)
            elif map_type == 'PC':
                prepare_material_for_pc(mat, settings, shared_image, report_data)
            elif map_type == 'ID':
                prepare_material_for_id(mat, settings, shared_image, report_data)
            elif map_type == 'C':
                prepare_material_for_diffuse(mat, settings, shared_image, report_data)
            elif map_type == 'N':
                prepare_material_for_normal(mat, settings, shared_image, report_data)

            report_data["processed"].append(mat.name)

    # Make sure one of the image nodes on the active object is active for baking
    active_obj = context.view_layer.objects.active
    if active_obj and active_obj.type == 'MESH' and active_obj.material_slots:
        image_node_name = f"{TEMP_PREFIX}Image_{map_type}"
        if map_type == 'N':
            image_node_name = f"{TEMP_PREFIX}Image_N"

        for slot in active_obj.material_slots:
            mat = slot.material
            if not mat or not mat.use_nodes or not mat.node_tree:
                continue
            for node in mat.node_tree.nodes:
                if node.name == image_node_name:
                    mat.node_tree.nodes.active = node
                    debug_print(settings, f"Set active image node {node.name} in {mat.name}")
                    break
            else:
                continue
            break

    return shared_image, report_data


def prepare_selected_objects_for_id_pass(context, settings, shared_image, alpha_pass=False):
    """
    Shared dispatcher for ID bakes.

    alpha_pass = False â†’ use prepare_material_for_id (RGB_ID â†’ Emission Color)
    alpha_pass = True  â†’ use prepare_material_for_id_alpha (Alpha_ID â†’ Emission Color)
    """
    report_data = {"skipped": [], "processed": []}

    map_label = "ID_A" if alpha_pass else "ID_C"
    image_node_name = f"{TEMP_PREFIX}Image_{map_label}"

    for obj in context.selected_objects:
        if obj.type != 'MESH':
            continue
        for slot in obj.material_slots:
            mat = slot.material
            if not mat:
                continue

            if alpha_pass:
                prepare_material_for_id_alpha(mat, settings, shared_image, report_data)
            else:
                prepare_material_for_id(mat, settings, shared_image, report_data)

            report_data["processed"].append(mat.name)

    # Make sure the correct temp image node is active on the active object for baking
    active_obj = context.view_layer.objects.active
    if active_obj and active_obj.type == 'MESH' and active_obj.material_slots:
        for slot in active_obj.material_slots:
            mat = slot.material
            if not mat or not mat.use_nodes or not mat.node_tree:
                continue
            for node in mat.node_tree.nodes:
                if node.name == image_node_name:
                    mat.node_tree.nodes.active = node
                    debug_print(settings, f"Set active image node {node.name} in {mat.name}")
                    return shared_image, report_data

    return shared_image, report_data


def clear_all_temp_nodes(context, settings):
    for obj in context.selected_objects:
        if obj.type != 'MESH':
            continue
        for slot in obj.material_slots:
            mat = slot.material
            if mat:
                clear_temp_nodes_from_material(mat, settings)


# ---------------------------------------------------------------------------
# Properties
# ---------------------------------------------------------------------------

class TEXTUREBAKER_Settings(PropertyGroup):

    # Existing bake map controls
    map_type: EnumProperty(
        name="Map Type",
        description="Type of map to build",
        items=[
            ('RMA', "RMA (R, M, AO)", "Roughness â†’ R, Metallic â†’ G, AO â†’ B"),
            ('MRA', "MRA (M, R, AO)", "Metallic â†’ R, Roughness â†’ G, AO â†’ B"),
            ('OBD', "OBD (A, 0, 0)", "Alpha â†’ R, G/B set to 0"),
            ('TSE', "TSE (0, Spec, Em)", "Translucency-style: 0 â†’ R, Specular/IOR â†’ G, Emission â†’ B"),
            ('N',   "Normal", "Normal map bake"),
            ('PC',  "Color (PC)", "Base Color + Alpha"),
            ('ID',  "ID", "Base Color / ID Core"),
            ('C',   "Diffuse / Grey", "Base Color, optional greyscale via HSV + Bright/Contrast"),
        ],
        default='RMA',
    )

    generate_ao: BoolProperty(
        name="Generate AO if Missing",
        description="Create a temporary Ambient Occlusion node if the material has none (RMA/MRA)",
        default=True,
    )

    # AO advanced controls
    ao_samples: IntProperty(
        name="AO Samples",
        description="Samples for generated AO node",
        default=64,
        min=1,
        max=4096,
    )

    ao_inside: BoolProperty(
        name="AO Inside",
        description="Use the 'Inside' option on the generated AO node",
        default=False,
    )

    ao_only_local: BoolProperty(
        name="AO Only Local",
        description="Use the 'Only Local' option on the generated AO node",
        default=True,
    )

    ao_distance: FloatProperty(
        name="AO Distance",
        description="Distance for generated AO node",
        default=10.0,
        min=0.0,
        soft_max=1000.0,
    )

    debug_mode: BoolProperty(
        name="Debug Print",
        description="Print verbose information to the console",
        default=False,
    )

    resolution_x: IntProperty(
        name="Width",
        description="Bake texture width",
        default=2048,
        min=64,
        max=16384,
    )

    resolution_y: IntProperty(
        name="Height",
        description="Bake texture height",
        default=2048,
        min=64,
        max=16384,
    )

    diffuse_grayscale: BoolProperty(
        name="Diffuse: Convert to Grayscale",
        description="For Diffuse (C) map: insert HSV + Bright/Contrast to make greyscale",
        default=False,
    )

    # --- Quick Weight Transfer options --------------------------------------
    auto_generate_data_layers: BoolProperty(
        name="Auto Generate Data Layers",
        description="Automatically run 'Generate Data Layers' for each Data Transfer modifier",
        default=True,
    )

    # --- Quick Tools settings ----------------------------------------- #

    consolidated_uv_name: StringProperty(
        name="UV Name",
        description="Name for the consolidated UV map created on all selected meshes",
        default="Consolidated",
    )

    consolidated_uv_override: BoolProperty(
        name="Override Existing",
        description="If enabled, reuse or create a UV map with this exact name; "
                    "if disabled, always create a new layer (which Blender will suffix .001, .002, ...)",
        default=True,
    )

    blend_mode: EnumProperty(
        name="Blend Mode",
        description="Set blend mode for all materials on selected meshes",
        items=[
            ('OPAQUE', "Opaque", "Fully opaque"),
            ('CLIP', "Alpha Clip", "Binary alpha cutout"),
            ('HASHED', "Alpha Hashed", "Dithered transparency"),
            ('BLEND', "Alpha Blend", "Standard alpha blending"),
        ],
        default='OPAQUE',
    )

    # --- Batch baking map selection (ID intentionally excluded) -----

    batch_rma: BoolProperty(
        name="RMA",
        description="Include RMA in batch bake",
        default=True,
    )

    batch_mra: BoolProperty(
        name="MRA",
        description="Include MRA in batch bake",
        default=False,
    )

    batch_obd: BoolProperty(
        name="OBD",
        description="Include OBD in batch bake",
        default=False,
    )

    batch_tse: BoolProperty(
        name="TSE",
        description="Include TSE in batch bake",
        default=False,
    )

    batch_pc: BoolProperty(
        name="PC",
        description="Include PC (Color + Alpha) in batch bake",
        default=False,
    )

    batch_c: BoolProperty(
        name="Diffuse",
        description="Include Diffuse (C) in batch bake",
        default=False,
    )

    batch_n: BoolProperty(
        name="Normal",
        description="Include Normal in batch bake",
        default=False,
    )


# ---------------------------------------------------------------------------
# Operators â€“ Bake System
# ---------------------------------------------------------------------------

class TEXTUREBAKER_OT_build_nodes(Operator):
    """Build / refresh temporary nodes for the selected map type (no bake yet)"""
    bl_idname = "t8tools.build_nodes"
    bl_label = "Build Channel Mix"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        settings = context.scene.texture_baker_settings

        if not context.selected_objects:
            self.report({'WARNING'}, "No selected objects.")
            return {'CANCELLED'}

        prepare_selected_objects_for_map(context, settings)
        self.report({'INFO'}, f"Temporary setup built for map type: {settings.map_type}")
        return {'FINISHED'}


class TEXTUREBAKER_OT_bake(Operator):
    """Bake the current map type to a consolidated texture"""
    bl_idname = "t8tools.bake"
    bl_label = "Bake"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        settings = context.scene.texture_baker_settings

        if not context.selected_objects:
            self.report({'WARNING'}, "No selected objects to bake.")
            return {'CANCELLED'}

        # Make sure we are in Object Mode
        if context.object and context.object.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')

        # Only meshes are valid bake targets
        meshes = [o for o in context.selected_objects if o.type == 'MESH']
        if not meshes:
            self.report({'WARNING'}, "No selected mesh objects to bake.")
            return {'CANCELLED'}

        # Ensure proper selection + active mesh for baking
        active_mesh = context.view_layer.objects.active
        if active_mesh not in meshes:
            active_mesh = meshes[0]
            context.view_layer.objects.active = active_mesh

        bpy.ops.object.select_all(action='DESELECT')
        for ob in meshes:
            ob.select_set(True)
        active_mesh.select_set(True)
        context.view_layer.objects.active = active_mesh

        # Build / refresh temp nodes and image
        img, report_data = prepare_selected_objects_for_map(context, settings)

        scene = context.scene
        scene.render.engine = 'CYCLES'

        # Decide bake type for non-ID maps
        if settings.map_type == 'N':
            bake_type = 'NORMAL'
        elif settings.map_type == 'PC':
            bake_type = 'COMBINED'
        else:
            bake_type = 'EMIT'

        # Speed-up and bake options (shared)
        old_samples = scene.cycles.samples
        scene.cycles.samples = 4

        old_clear = scene.render.bake.use_clear
        scene.render.bake.use_clear = False

        # Ensure we are NOT in Selected to Active mode
        old_sta = scene.render.bake.use_selected_to_active
        scene.render.bake.use_selected_to_active = False

        try:
            if settings.map_type != 'ID':
                # --- Original single-pass behavior for all other map types ---
                scene.cycles.bake_type = bake_type

                img, report_data = prepare_selected_objects_for_map(context, settings)

                debug_print(
                    settings,
                    f"Baking map {settings.map_type} to image '{img.name}' "
                    f"({img.size[0]}x{img.size[1]}) on active mesh {active_mesh.name}"
                )

                try:
                    bpy.ops.object.bake(type=scene.cycles.bake_type)
                except RuntimeError as e:
                    self.report({'ERROR'}, f"Bake failed: {e}")
                    return {'CANCELLED'}

                if report_data["skipped"]:
                    self.report(
                        {'WARNING'},
                        f"Bake finished. Skipped: {len(report_data['skipped'])} material(s). "
                        "Check console for details."
                    )
                    for msg in report_data["skipped"]:
                        debug_print(settings, msg)
                else:
                    self.report({'INFO'}, "Bake finished successfully.")

            else:
                # --- Special two-pass behavior for ID maps (Color + Alpha) ---
                scene.cycles.bake_type = 'EMIT'

                # Pass 1: Color ID (RGB_ID â†’ Emission Color) â†’ _C_ID
                img_c = ensure_image_for_map(settings, 'ID_C', context)
                img_c, report_c = prepare_selected_objects_for_id_pass(
                    context, settings, img_c, alpha_pass=False
                )

                debug_print(
                    settings,
                    f"Baking ID Color (RGB_ID) to image '{img_c.name}' "
                    f"({img_c.size[0]}x{img_c.size[1]}) on active mesh {active_mesh.name}"
                )

                try:
                    bpy.ops.object.bake(type='EMIT')
                except RuntimeError as e:
                    self.report({'ERROR'}, f"Color ID bake failed: {e}")
                    return {'CANCELLED'}

                # Pass 2: Alpha ID (Alpha_ID â†’ greyscale Emission Color) â†’ _A_ID
                img_a = ensure_image_for_map(settings, 'ID_A', context)
                img_a, report_a = prepare_selected_objects_for_id_pass(
                    context, settings, img_a, alpha_pass=True
                )

                debug_print(
                    settings,
                    f"Baking ID Alpha (Alpha_ID) to image '{img_a.name}' "
                    f"({img_a.size[0]}x{img_a.size[1]}) on active mesh {active_mesh.name}"
                )

                try:
                    bpy.ops.object.bake(type='EMIT')
                except RuntimeError as e:
                    self.report({'ERROR'}, f"Alpha ID bake failed: {e}")
                    return {'CANCELLED'}

                # User feedback
                skipped_total = len(report_c["skipped"]) + len(report_a["skipped"])
                if skipped_total:
                    self.report(
                        {'WARNING'},
                        f"ID bakes finished. Skipped {skipped_total} material(s) across both passes. "
                        "Check console for details."
                    )
                    for msg in report_c["skipped"] + report_a["skipped"]:
                        debug_print(settings, msg)
                else:
                    self.report(
                        {'INFO'},
                        f"ID bakes finished successfully. "
                        f"Generated '{img_c.name}' and '{img_a.name}'."
                    )

        finally:
            scene.cycles.samples = old_samples
            scene.render.bake.use_clear = old_clear
            scene.render.bake.use_selected_to_active = old_sta

        return {'FINISHED'}


class TEXTUREBAKER_OT_clear(Operator):
    """Clear all temporary nodes created by Texture Baker on selected objects"""
    bl_idname = "t8tools.clear"
    bl_label = "Clear Temporary Nodes"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        settings = context.scene.texture_baker_settings
        clear_all_temp_nodes(context, settings)
        self.report({'INFO'}, "Cleared Texture Baker temporary nodes on selected objects.")
        return {'FINISHED'}


# ---------------------------------------------------------------------------
# Panels â€“ Baking (hooked under T8 Tools > Baking Tools)
# ---------------------------------------------------------------------------

class TEXTUREBAKER_PT_panel(Panel):
    bl_label = "Texture Baker"
    bl_idname = "TEXTUREBAKER_PT_panel"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "T8 Tools"
    bl_parent_id = "VIEW3D_PT_t8tools_baking"
    bl_options = {'DEFAULT_CLOSED'}  # Collapsed by default

    @classmethod
    def poll(cls, context):
        return context.scene is not None and hasattr(context.scene, "texture_baker_settings")

    def draw(self, context):
        layout = self.layout
        settings = context.scene.texture_baker_settings

        row = layout.row()
        row.operator(
            "wm.url_open",
            text="ðŸ“˜ Online Documentation"
        ).url = "https://github.com/CDDTreborn/Tekken-8-Resources/wiki/Texture-Baker-%E2%80%93-Blender-Add%E2%80%90On-%E2%80%90-Guide"

        col = layout.column(align=True)
        col.label(text="Map Settings:")
        col.prop(settings, "map_type", text="Type")
        col.prop(settings, "generate_ao")

        if settings.generate_ao:
            box = col.box()
            box.label(text="AO Settings:")
            box.prop(settings, "ao_samples")
            box.prop(settings, "ao_inside")
            box.prop(settings, "ao_only_local")
            box.prop(settings, "ao_distance")

        col.prop(settings, "debug_mode")

        if settings.map_type == 'C':
            col.prop(settings, "diffuse_grayscale")

        col.separator()
        col.label(text="Image Resolution:")
        row = col.row(align=True)
        row.prop(settings, "resolution_x")
        row.prop(settings, "resolution_y")

        col.separator()
        col.operator("texture_baker.build_nodes", text="Build / Refresh Setup")
        col.operator("texture_baker.bake", text="Bake")
        col.operator("texture_baker.clear", text="Clear Temporary Nodes")


# ---------------------------------------------------------------------------
# Registration
# ---------------------------------------------------------------------------

classes = (
    TEXTUREBAKER_Settings,
    TEXTUREBAKER_OT_build_nodes,
    TEXTUREBAKER_OT_bake,
    TEXTUREBAKER_OT_clear,
    TEXTUREBAKER_PT_panel,
)


def register():
    from bpy.utils import register_class
    for cls in classes:
        register_class(cls)
    bpy.types.Scene.texture_baker_settings = PointerProperty(
        type=TEXTUREBAKER_Settings
    )


def unregister():
    from bpy.utils import unregister_class
    if hasattr(bpy.types.Scene, "texture_baker_settings"):
        del bpy.types.Scene.texture_baker_settings
    for cls in reversed(classes):
        unregister_class(cls)
